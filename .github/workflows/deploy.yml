name: Deploy to Production

on:
  push:
    branches: [ "main" ]

concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract version info
        id: version
        run: |
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          VERSION="prod-${SHORT_SHA}-${TIMESTAMP}"

          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Build and Push Docker image
        id: docker_build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ahnco/eventitta:${{ steps.version.outputs.version }}
          cache-from: type=registry,ref=ahnco/eventitta:buildcache
          cache-to: type=registry,ref=ahnco/eventitta:buildcache,mode=max
          provenance: false

      - name: Display build info
        run: |
          echo "‚úÖ Successfully pushed image"
          echo "üì¶ Image: ahnco/eventitta:${{ steps.version.outputs.version }}"
          echo "üîí Digest: ${{ steps.docker_build.outputs.digest }}"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_TAG: ${{ steps.version.outputs.version }}
          IMAGE_DIGEST: ${{ steps.docker_build.outputs.digest }}
          DEPLOY_MODE: ${{ vars.DEPLOY_MODE || 'tag' }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_KEY }}
          script_stop: true
          command_timeout: 10m
          envs: IMAGE_TAG,IMAGE_DIGEST,DEPLOY_MODE
          script: |
            set -euo pipefail

            echo "========================================="
            echo "üöÄ Starting Production Deployment"
            echo "========================================="
            echo "Deploy Mode: $DEPLOY_MODE"
            echo "Version: $IMAGE_TAG"
            echo "Digest: $IMAGE_DIGEST"
            echo "Commit: ${{ steps.version.outputs.short_sha }}"
            echo "Deployed by: ${{ github.actor }}"
            echo "Time: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""

            cd ~/eventitta

            # Î∞∞Ìè¨ Ïù¥Î†• Ï†ÄÏû•
            echo "$IMAGE_TAG|$IMAGE_DIGEST|$(date '+%Y-%m-%d %H:%M:%S')" >> .deploy_history
            tail -100 .deploy_history > .deploy_history.tmp && mv .deploy_history.tmp .deploy_history

            # ÌòÑÏû¨ Î≤ÑÏ†Ñ Î∞±ÏóÖ
            PREVIOUS_IMAGE=""
            if [ -f .current_image ]; then
              PREVIOUS_IMAGE=$(cat .current_image)
              echo "üì¶ Previous image: $PREVIOUS_IMAGE"
            fi

            # ÌòÑÏû¨ Ïã§Ìñâ Ï§ëÏù∏ Ïª®ÌÖåÏù¥ÎÑà ÌôïÏù∏
            echo "üì¶ Current running container:"
            docker ps --filter "name=eventitta-app" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}" || echo "No container running"
            echo ""

            # ‚úÖ Î∞∞Ìè¨Ìï† Ïù¥ÎØ∏ÏßÄ Í≤∞Ï†ï (ÌÉúÍ∑∏ vs Îã§Ïù¥Ï†úÏä§Ìä∏)
            if [ "$DEPLOY_MODE" = "digest" ]; then
              APP_IMAGE="ahnco/eventitta@${IMAGE_DIGEST}"
              echo "üîí Using digest-based deployment for maximum reproducibility"
            else
              APP_IMAGE="ahnco/eventitta:${IMAGE_TAG}"
              echo "üè∑Ô∏è  Using tag-based deployment"
            fi

            echo "üì¶ Target image: $APP_IMAGE"
            echo ""

            # .env ÌååÏùº ÏÉùÏÑ± (heredoc Î≥ÄÏàò ÏπòÌôò Ï≤òÎ¶¨)
            echo "üìù Creating .env file..."

            # ‚úÖ heredoc Îî∞Ïò¥Ìëú ÏóÜÏù¥ ÏÇ¨Ïö©ÌïòÏó¨ Î≥ÄÏàò ÌôïÏû• ÌóàÏö©
            cat > .env.tmp << EOF
            # --- Docker Image ---
            APP_IMAGE=${APP_IMAGE}

            # --- Server ---
            SERVER_PORT=${{ secrets.SERVER_PORT }}

            # --- File Upload ---
            FILE_STORAGE_LOCATION=${{ secrets.FILE_STORAGE_LOCATION }}

            # --- Logging ---
            LOG_FILE_PATH=${{ secrets.LOG_FILE_PATH }}

            # --- Slack Notifications ---
            SLACK_CHANNEL=${{ secrets.SLACK_CHANNEL }}
            SLACK_USERNAME=${{ secrets.SLACK_USERNAME }}
            SLACK_TIMEOUT=${{ secrets.SLACK_TIMEOUT }}
            EOF

            mv .env.tmp .env
            chmod 600 .env

            # ÎØºÍ∞êÌïú Ï†ïÎ≥¥Îäî Î≥ÑÎèÑ ÌååÏùº
            cat > .env.secrets.tmp << EOF
            # --- Database (RDS) ---
            RDS_ENDPOINT=${{ secrets.RDS_ENDPOINT }}
            DB_NAME=${{ secrets.DB_NAME }}
            JDBC_USERNAME=${{ secrets.JDBC_USERNAME }}
            JDBC_PASSWORD=${{ secrets.JDBC_PASSWORD }}

            # --- JWT ---
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_ACCESS_TOKEN_VALIDITY=${{ secrets.JWT_ACCESS_TOKEN_VALIDITY }}
            JWT_REFRESH_TOKEN_VALIDITY=${{ secrets.JWT_REFRESH_TOKEN_VALIDITY }}

            # --- Open API Keys ---
            SEOUL_API_KEY=${{ secrets.SEOUL_API_KEY }}
            NATIONAL_API_KEY=${{ secrets.NATIONAL_API_KEY }}

            # --- AWS S3 ---
            AWS_REGION=${{ secrets.AWS_REGION }}
            S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
            AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}

            # --- Slack Webhook ---
            SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}

            # --- Geo Coding ---
            GEOCODING_CONTACT_EMAIL=${{ secrets.GEOCODING_CONTACT_EMAIL }}
            EOF

            mv .env.secrets.tmp .env.secrets
            chmod 400 .env.secrets

            echo "‚úÖ Environment files created"
            echo ""

            # Ïù¥ÎØ∏ÏßÄ Pull
            echo "‚¨áÔ∏è  Pulling image from Docker Hub..."
            docker pull $APP_IMAGE
            echo "‚úÖ Image pulled successfully"
            echo ""

            # ‚úÖ docker compose ÏÇ¨Ïö© (V2)
            # docker-compose.ymlÏóêÏÑú ${APP_IMAGE} Î≥ÄÏàò ÏÇ¨Ïö©
            export APP_IMAGE

            # Ïª®ÌÖåÏù¥ÎÑà Ïû¨ÏãúÏûë
            echo "üîÑ Deploying new version..."
            docker compose up -d --force-recreate
            echo ""

            # Ìó¨Ïä§Ï≤¥ÌÅ¨
            echo "‚è≥ Performing health check..."
            HEALTH_CHECK_PASSED=false
            MAX_ATTEMPTS=40

            for i in $(seq 1 $MAX_ATTEMPTS); do
              sleep 3

              # Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä Ïã§Ìñâ Ï§ëÏù∏ÏßÄ ÌôïÏù∏
              if ! docker ps --filter "name=eventitta-app" --filter "status=running" -q | grep -q .; then
                echo "‚ùå Container stopped unexpectedly!"
                echo ""
                echo "üìù Container logs:"
                docker logs eventitta-app --tail 100 2>&1 || true
                break
              fi

              # Spring Boot ÏãúÏûë ÏôÑÎ£å ÌôïÏù∏
              if docker logs eventitta-app 2>&1 | grep -qi "Started.*Application"; then
                echo "‚úÖ Spring Boot application started! (attempt $i/$MAX_ATTEMPTS)"
                sleep 5

                # HTTP ÏùëÎãµ ÌôïÏù∏
                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${SERVER_PORT:-8080}/ 2>/dev/null || echo "000")

                if [ "$HTTP_CODE" != "000" ]; then
                  echo "‚úÖ HTTP endpoint responding with code: $HTTP_CODE"
                  HEALTH_CHECK_PASSED=true
                  break
                fi
              fi

              echo "‚è≥ Waiting for application... (attempt $i/$MAX_ATTEMPTS)"
            done

            echo ""

            # Í≤∞Í≥º Ï≤òÎ¶¨
            if [ "$HEALTH_CHECK_PASSED" = true ]; then
              # ÌòÑÏû¨ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû•
              echo "$APP_IMAGE" > .current_image

              echo "========================================="
              echo "‚úÖ Deployment Successful!"
              echo "========================================="
              echo "Image: $APP_IMAGE"
              echo "Version: $IMAGE_TAG"
              echo "Digest: $IMAGE_DIGEST"
              echo ""
              echo "üìä Container Status:"
              docker ps --filter "name=eventitta-app" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
              echo ""
              echo "üìù Recent Logs (last 30 lines):"
              docker logs eventitta-app --tail 30
              echo ""
              echo "üéâ Production is now running: $APP_IMAGE"

              # Ïù¥Ï†Ñ Ïù¥ÎØ∏ÏßÄ Ï†ïÎ¶¨ (ÏµúÍ∑º 5Í∞úÎßå Ïú†ÏßÄ)
              echo ""
              echo "üßπ Cleaning up old images..."
              docker images ahnco/eventitta --format "{{.Tag}}" \
                | grep "^prod-" \
                | sort -r \
                | tail -n +6 \
                | xargs -r -I {} docker rmi ahnco/eventitta:{} 2>/dev/null || true

            else
              echo "========================================="
              echo "‚ùå Deployment Failed!"
              echo "========================================="
              echo ""
              echo "üìù Full Container Logs:"
              docker logs eventitta-app --tail 200 2>&1 || true
              echo ""
              echo "üìä Container Status:"
              docker ps -a --filter "name=eventitta-app"
              echo ""

              # ‚úÖ Î°§Î∞± (ÌôòÍ≤ΩÎ≥ÄÏàò Í∏∞Î∞ò)
              if [ -n "$PREVIOUS_IMAGE" ]; then
                echo "üîÑ Attempting rollback to: $PREVIOUS_IMAGE"
                export APP_IMAGE="$PREVIOUS_IMAGE"

                # Ïù¥Ï†Ñ Ïù¥ÎØ∏ÏßÄ Pull
                docker pull $PREVIOUS_IMAGE 2>/dev/null || true

                # Î°§Î∞± Ïã§Ìñâ
                docker compose up -d --force-recreate

                # Î°§Î∞± Í≤ÄÏ¶ù
                sleep 5
                if docker ps --filter "name=eventitta-app" --filter "status=running" -q | grep -q .; then
                  echo "‚úÖ Rollback successful"
                  echo "Current image: $PREVIOUS_IMAGE"
                else
                  echo "‚ùå Rollback also failed - manual intervention required!"
                fi
              else
                echo "‚ö†Ô∏è  No previous version available for rollback"
              fi

              exit 1
            fi
