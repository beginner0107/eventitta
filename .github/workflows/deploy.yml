name: Deploy to Production

on:
  push:
    branches: [ "main" ]

concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract version info
        id: version
        run: |
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          VERSION="prod-${SHORT_SHA}-${TIMESTAMP}"

          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Build and Push Docker image
        id: docker_build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ahnco/eventitta:${{ steps.version.outputs.version }}
          cache-from: type=registry,ref=ahnco/eventitta:buildcache
          cache-to: type=registry,ref=ahnco/eventitta:buildcache,mode=max
          provenance: false

      - name: Display build info
        run: |
          echo "‚úÖ Successfully pushed image"
          echo "üì¶ Image: ahnco/eventitta:${{ steps.version.outputs.version }}"
          echo "üîí Digest: ${{ steps.docker_build.outputs.digest }}"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          # Î∞∞Ìè¨ Î©îÌÉÄ Ï†ïÎ≥¥
          DEPLOY_MODE: tag
          IMAGE_TAG: ${{ steps.version.outputs.version }}
          IMAGE_DIGEST: ${{ steps.docker_build.outputs.digest }}
          ACTOR: ${{ github.actor }}
          # Îü∞ÌÉÄÏûÑ/ÏÑúÎ≤Ñ ÏÑ§Ï†ï
          SERVER_PORT: 8080
          REMOTE_DIR: ${{ secrets.REMOTE_DIR }}
          FILE_STORAGE_LOCATION: ${{ secrets.FILE_STORAGE_LOCATION }}
          LOG_FILE_PATH: ${{ secrets.LOG_FILE_PATH }}
          SLACK_CHANNEL: ${{ secrets.SLACK_CHANNEL }}
          SLACK_USERNAME: ${{ secrets.SLACK_USERNAME }}
          SLACK_TIMEOUT: ${{ secrets.SLACK_TIMEOUT }}
          # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§/ÏãúÌÅ¨Î¶ø
          RDS_ENDPOINT: ${{ secrets.RDS_ENDPOINT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          JDBC_USERNAME: ${{ secrets.JDBC_USERNAME }}
          JDBC_PASSWORD: ${{ secrets.JDBC_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_ACCESS_TOKEN_VALIDITY: ${{ secrets.JWT_ACCESS_TOKEN_VALIDITY }}
          JWT_REFRESH_TOKEN_VALIDITY: ${{ secrets.JWT_REFRESH_TOKEN_VALIDITY }}
          SEOUL_API_KEY: ${{ secrets.SEOUL_API_KEY }}
          NATIONAL_API_KEY: ${{ secrets.NATIONAL_API_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          GEOCODING_CONTACT_EMAIL: ${{ secrets.GEOCODING_CONTACT_EMAIL }}
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          # portÎäî Í∏∞Î≥∏Í∞í(22) ÏÇ¨Ïö©. ÌïÑÏöî Ïãú secrets.SSH_PORTÎ•º ÎßåÎì§Í≥† Îã§Ïùå Ï§ÑÏùÑ ÌôúÏÑ±ÌôîÌïòÏÑ∏Ïöî.
          # port: ${{ secrets.SSH_PORT }}
          script_stop: true
          command_timeout: 30m
          # Ï†ÑÎã¨Ìï† ÌôòÍ≤ΩÎ≥ÄÏàò Î™©Î°ù (ÏΩ§Îßà Íµ¨Î∂Ñ)
          envs: DEPLOY_MODE,IMAGE_TAG,IMAGE_DIGEST,ACTOR,SERVER_PORT,REMOTE_DIR,FILE_STORAGE_LOCATION,LOG_FILE_PATH,SLACK_CHANNEL,SLACK_USERNAME,SLACK_TIMEOUT,RDS_ENDPOINT,DB_NAME,JDBC_USERNAME,JDBC_PASSWORD,JWT_SECRET,JWT_ACCESS_TOKEN_VALIDITY,JWT_REFRESH_TOKEN_VALIDITY,SEOUL_API_KEY,NATIONAL_API_KEY,AWS_REGION,S3_BUCKET_NAME,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,SLACK_WEBHOOK_URL,GEOCODING_CONTACT_EMAIL
          script: |
            set -euo pipefail

            echo "========================================="
            echo "üöÄ Starting Production Deployment"
            echo "========================================="

            # ÌôòÍ≤ΩÎ≥ÄÏàò Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
            DEPLOY_MODE="${DEPLOY_MODE:-tag}"
            SERVER_PORT="${SERVER_PORT:-8080}"
            REMOTE_DIR="${REMOTE_DIR:-~/eventitta}"

            echo "Deploy Mode: $DEPLOY_MODE"
            echo "Version: ${IMAGE_TAG:-<none>}"
            echo "Digest: ${IMAGE_DIGEST:-<none>}"
            echo "Deployed by: ${ACTOR:-unknown}"
            echo "Server Port: $SERVER_PORT"
            echo "Remote Dir: $REMOTE_DIR"
            echo "Time: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""

            # ÏûëÏóÖ ÎîîÎ†âÌÑ∞Î¶¨ Ïù¥Îèô
            echo "üîç Changing to directory: $REMOTE_DIR"
            cd "$REMOTE_DIR" || { echo "‚ùå Failed to cd to $REMOTE_DIR"; exit 1; }
            echo "‚úÖ Changed to directory: $(pwd)"
            echo ""

            # Î∞∞Ìè¨ ÎåÄÏÉÅ Ïù¥ÎØ∏ÏßÄ Í≤∞Ï†ï
            echo "üîç Determining target image..."
            if [ "$DEPLOY_MODE" = "digest" ]; then
              APP_IMAGE="ahnco/eventitta@${IMAGE_DIGEST}"
              echo "üîí Using digest-based deployment"
            else
              APP_IMAGE="ahnco/eventitta:${IMAGE_TAG}"
              echo "üè∑Ô∏è  Using tag-based deployment"
            fi
            echo "üì¶ Target image: $APP_IMAGE"
            echo ""

            # .env ÌååÏùº ÏÉùÏÑ±
            echo "üìù Creating .env file..."
            cat > .env <<EOF
  APP_IMAGE=${APP_IMAGE}
  APP_PORT=${SERVER_PORT}
  SERVER_PORT=${SERVER_PORT}
  FILE_STORAGE_LOCATION=${FILE_STORAGE_LOCATION:-/tmp/uploads}
  LOG_FILE_PATH=${LOG_FILE_PATH:-/tmp/logs}
  SLACK_CHANNEL=${SLACK_CHANNEL:-general}
  SLACK_USERNAME=${SLACK_USERNAME:-bot}
  SLACK_TIMEOUT=${SLACK_TIMEOUT:-5000}
  EOF
  chmod 600 .env
  echo "‚úÖ .env file created"
  echo ""

  # .env.secrets ÌååÏùº ÏÉùÏÑ±
  echo "üìù Creating .env.secrets file..."
  cat > .env.secrets <<EOF
  SECRET_KEY=${JWT_SECRET}
  MYSQL_DATABASE=${DB_NAME}
  MYSQL_USER=${JDBC_USERNAME}
  MYSQL_PASSWORD=${JDBC_PASSWORD}
  RDS_ENDPOINT=${RDS_ENDPOINT}
  DB_NAME=${DB_NAME}
  JDBC_USERNAME=${JDBC_USERNAME}
  JDBC_PASSWORD=${JDBC_PASSWORD}
  JWT_SECRET=${JWT_SECRET}
  JWT_ACCESS_TOKEN_VALIDITY=${JWT_ACCESS_TOKEN_VALIDITY:-3600000}
  JWT_REFRESH_TOKEN_VALIDITY=${JWT_REFRESH_TOKEN_VALIDITY:-86400000}
  SEOUL_API_KEY=${SEOUL_API_KEY}
  NATIONAL_API_KEY=${NATIONAL_API_KEY}
  AWS_REGION=${AWS_REGION}
  S3_BUCKET_NAME=${S3_BUCKET_NAME}
  AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
  AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
  SLACK_WEBHOOK_URL=${SLACK_WEBHOOK_URL}
  GEOCODING_CONTACT_EMAIL=${GEOCODING_CONTACT_EMAIL}
  EOF
  chmod 400 .env.secrets
  echo "‚úÖ .env.secrets file created"
  echo ""

  # Ïù¥ÎØ∏ÏßÄ Pull
  echo "‚¨áÔ∏è  Pulling image from Docker Hub..."
  if docker pull "$APP_IMAGE"; then
  echo "‚úÖ Image pulled successfully"
  else
echo "‚ùå Failed to pull image: $APP_IMAGE"
  exit 1
  fi
  echo ""

  # Docker Compose Î™ÖÎ†πÏñ¥ ÌôïÏù∏
  echo "üîç Checking Docker Compose..."
  if docker compose version >/dev/null 2>&1; then
  DOCKER_COMPOSE="docker compose"
  echo "‚úÖ Using Docker Compose V2"
  elif command -v docker-compose >/dev/null 2>&1; then
  DOCKER_COMPOSE="docker-compose"
  echo "‚úÖ Using Docker Compose V1"
  else
  echo "‚ùå Docker Compose not found"
  exit 1
  fi
  echo ""

  # APP_IMAGE ÌôòÍ≤ΩÎ≥ÄÏàò export
  export APP_IMAGE
  echo "‚úÖ Exported APP_IMAGE=$APP_IMAGE"
  echo ""

  # Î∞∞Ìè¨ Ïã§Ìñâ
  echo "üîÑ Deploying new version..."
  if $DOCKER_COMPOSE up -d --force-recreate; then
  echo "‚úÖ Containers started"
  else
  echo "‚ùå Failed to start containers"
  docker ps -a
  exit 1
  fi
  echo ""

  # Ìó¨Ïä§Ï≤¥ÌÅ¨
  echo "‚è≥ Performing health check..."
  HEALTH_CHECK_PASSED=false
  MAX_ATTEMPTS=40
  SLEEP_BETWEEN=3

  for i in $(seq 1 $MAX_ATTEMPTS); do
  sleep $SLEEP_BETWEEN

  # Ïª®ÌÖåÏù¥ÎÑà Ïã§Ìñâ ÏÉÅÌÉú ÌôïÏù∏
  if ! docker ps --filter "name=eventitta-app" --filter "status=running" -q | grep -q .; then
  echo "‚ùå Container not running (attempt $i/$MAX_ATTEMPTS)"
  docker logs eventitta-app --tail 50 2>&1 || true
  break
  fi

  # Spring Boot ÏãúÏûë Î°úÍ∑∏ ÌôïÏù∏
  if docker logs eventitta-app 2>&1 | grep -qi "Started.*Application"; then
  echo "‚úÖ Spring Boot application started! (attempt $i/$MAX_ATTEMPTS)"
  sleep 5

  # HTTP ÏóîÎìúÌè¨Ïù∏Ìä∏ ÌôïÏù∏
  HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:${SERVER_PORT}/" 2>/dev/null || echo "000")
  if [ "$HTTP_CODE" != "000" ]; then
echo "‚úÖ HTTP endpoint responding with code: $HTTP_CODE"
  HEALTH_CHECK_PASSED=true
  break
  fi
  fi

  echo "‚è≥ Waiting for application... (attempt $i/$MAX_ATTEMPTS)"
  done

  echo ""
  if [ "$HEALTH_CHECK_PASSED" = true ]; then
  echo "$APP_IMAGE" > "$REMOTE_DIR/.current_image"
  echo "========================================="
  echo "‚úÖ Deployment Successful!"
  echo "========================================="
echo "Image: $APP_IMAGE"
echo "Version: ${IMAGE_TAG:-<none>}"
  echo ""
  echo "üìä Container Status:"
  docker ps --filter "name=eventitta-app" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
  echo ""
  echo "üìù Recent Logs:"
  docker logs eventitta-app --tail 20
  echo ""
  echo "üéâ Production is now running!"

  # Ïò§ÎûòÎêú Ïù¥ÎØ∏ÏßÄ Ï†ïÎ¶¨
  echo ""
  echo "üßπ Cleaning up old images..."
  docker images ahnco/eventitta --format "{{.Tag}}" | grep "^prod-" | sort -r | tail -n +6 | xargs -r -I {} docker rmi ahnco/eventitta:{} 2>/dev/null || true
  echo "‚úÖ Cleanup complete"
  else
  echo "========================================="
  echo "‚ùå Deployment Failed!"
  echo "========================================="
  echo ""
  echo "üìù Full Container Logs:"
  docker logs eventitta-app --tail 100 2>&1 || true
  echo ""
  echo "üìä Container Status:"
  docker ps -a --filter "name=eventitta-app"

  # Î°§Î∞± ÏãúÎèÑ
  if [ -f "$REMOTE_DIR/.current_image" ]; then
  PREVIOUS_IMAGE=$(cat "$REMOTE_DIR/.current_image")
  if [ -n "$PREVIOUS_IMAGE" ]; then
  echo ""
echo "üîÑ Attempting rollback to: $PREVIOUS_IMAGE"
  export APP_IMAGE="$PREVIOUS_IMAGE"
  docker pull "$PREVIOUS_IMAGE" 2>/dev/null || true
  $DOCKER_COMPOSE up -d --force-recreate
  sleep 5
  if docker ps --filter "name=eventitta-app" --filter "status=running" -q | grep -q .; then
  echo "‚úÖ Rollback successful"
  else
  echo "‚ùå Rollback failed"
  fi
  fi
  fi
  exit 1
  fi
