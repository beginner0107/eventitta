name: Deploy to Production

on:
  push:
    branches: [ "main" ]

concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract version info
        id: version
        run: |
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          VERSION="prod-${SHORT_SHA}-${TIMESTAMP}"
          
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Build and Push Docker image
        id: docker_build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ahnco/eventitta:${{ steps.version.outputs.version }}
          cache-from: type=registry,ref=ahnco/eventitta:buildcache
          cache-to: type=registry,ref=ahnco/eventitta:buildcache,mode=max
          provenance: false

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          DEPLOY_MODE: tag
          IMAGE_TAG: ${{ steps.version.outputs.version }}
          IMAGE_DIGEST: ${{ steps.docker_build.outputs.digest }}
          ACTOR: ${{ github.actor }}
          SERVER_PORT: ${{ secrets.SERVER_PORT }}
          REMOTE_DIR: ${{ secrets.REMOTE_DIR }}
          FILE_STORAGE_LOCATION: ${{ secrets.FILE_STORAGE_LOCATION }}
          LOG_FILE_PATH: ${{ secrets.LOG_FILE_PATH }}
          SLACK_CHANNEL: ${{ secrets.SLACK_CHANNEL }}
          SLACK_USERNAME: ${{ secrets.SLACK_USERNAME }}
          SLACK_TIMEOUT: ${{ secrets.SLACK_TIMEOUT }}
          RDS_ENDPOINT: ${{ secrets.RDS_ENDPOINT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          JDBC_USERNAME: ${{ secrets.JDBC_USERNAME }}
          JDBC_PASSWORD: ${{ secrets.JDBC_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_ACCESS_TOKEN_VALIDITY: ${{ secrets.JWT_ACCESS_TOKEN_VALIDITY }}
          JWT_REFRESH_TOKEN_VALIDITY: ${{ secrets.JWT_REFRESH_TOKEN_VALIDITY }}
          SEOUL_API_KEY: ${{ secrets.SEOUL_API_KEY }}
          NATIONAL_API_KEY: ${{ secrets.NATIONAL_API_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          GEOCODING_CONTACT_EMAIL: ${{ secrets.GEOCODING_CONTACT_EMAIL }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT || 22 }}
          script_stop: true
          command_timeout: 30m
          envs: DEPLOY_MODE,IMAGE_TAG,IMAGE_DIGEST,ACTOR,SERVER_PORT,REMOTE_DIR,FILE_STORAGE_LOCATION,LOG_FILE_PATH,SLACK_CHANNEL,SLACK_USERNAME,SLACK_TIMEOUT,RDS_ENDPOINT,DB_NAME,JDBC_USERNAME,JDBC_PASSWORD,JWT_SECRET,JWT_ACCESS_TOKEN_VALIDITY,JWT_REFRESH_TOKEN_VALIDITY,SEOUL_API_KEY,NATIONAL_API_KEY,AWS_REGION,S3_BUCKET_NAME,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,SLACK_WEBHOOK_URL,GEOCODING_CONTACT_EMAIL
          script: |
            #!/bin/bash
            set -euo pipefail
            
            # ÏóêÎü¨ Î∞úÏÉù Ïãú ÎùºÏù∏ Î≤àÌò∏ Ï∂úÎ†•
            trap 'echo "Error at line $LINENO"' ERR
            
            echo "========================================="
            echo "üöÄ Starting Production Deployment"
            echo "========================================="
            echo "Current directory: $(pwd)"
            echo "User: $(whoami)"
            
            # ÌïÑÏàò ÌôòÍ≤Ω Î≥ÄÏàò ÌôïÏù∏
            if [ -z "${IMAGE_TAG:-}" ]; then
              echo "‚ùå ERROR: IMAGE_TAG is empty"
              exit 1
            fi
            
            # REMOTE_DIR Ï≤òÎ¶¨
            if [ -z "${REMOTE_DIR:-}" ]; then
              REMOTE_DIR="$HOME/eventitta"
              echo "‚ö†Ô∏è Using default REMOTE_DIR: $REMOTE_DIR"
            else
              # Ìã∏ÎìúÎ•º Ìôà ÎîîÎ†âÌÜ†Î¶¨Î°ú Î≥ÄÌôò
              REMOTE_DIR="${REMOTE_DIR/#\~/$HOME}"
            fi
            
            if [ -z "${SERVER_PORT:-}" ]; then
              SERVER_PORT="8080"
              echo "‚ö†Ô∏è Using default SERVER_PORT: $SERVER_PORT"
            fi
            
            echo "Deploy Mode: ${DEPLOY_MODE:-tag}"
            echo "Version: $IMAGE_TAG"
            echo "Digest: ${IMAGE_DIGEST:-none}"
            echo "Deployed by: ${ACTOR:-unknown}"
            echo "Server Port: $SERVER_PORT"
            echo "Remote Dir: $REMOTE_DIR"
            echo "Time: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""
            
            # ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ± Î∞è Ïù¥Îèô
            echo "Creating directory: $REMOTE_DIR"
            mkdir -p "$REMOTE_DIR"
            cd "$REMOTE_DIR"
            echo "‚úÖ Changed to directory: $(pwd)"
            echo ""
            
            # Docker Ïù¥ÎØ∏ÏßÄ ÏÑ§Ï†ï
            DOCKER_REPO="ahnco/eventitta"
            
            if [ "${DEPLOY_MODE:-tag}" = "digest" ] && [ -n "${IMAGE_DIGEST:-}" ]; then
              APP_IMAGE="${DOCKER_REPO}@${IMAGE_DIGEST}"
              echo "üîí Using digest-based deployment"
            else
              APP_IMAGE="${DOCKER_REPO}:${IMAGE_TAG}"
              echo "üè∑Ô∏è Using tag-based deployment"
            fi
            echo "üì¶ Target image: $APP_IMAGE"
            echo ""
            
            # .env ÌååÏùº ÏÉùÏÑ± (printf ÏÇ¨Ïö©)
            echo "üìù Creating .env file..."
            {
              printf "APP_IMAGE=%s\n" "$APP_IMAGE"
              printf "SERVER_PORT=%s\n" "${SERVER_PORT:-8080}"
              printf "FILE_STORAGE_LOCATION=%s\n" "${FILE_STORAGE_LOCATION:-}"
              printf "LOG_FILE_PATH=%s\n" "${LOG_FILE_PATH:-}"
              printf "SLACK_CHANNEL=%s\n" "${SLACK_CHANNEL:-}"
              printf "SLACK_USERNAME=%s\n" "${SLACK_USERNAME:-}"
              printf "SLACK_TIMEOUT=%s\n" "${SLACK_TIMEOUT:-}"
              printf "RDS_ENDPOINT=%s\n" "${RDS_ENDPOINT:-}"
              printf "DB_NAME=%s\n" "${DB_NAME:-}"
              printf "JDBC_USERNAME=%s\n" "${JDBC_USERNAME:-}"
              printf "JDBC_PASSWORD=%s\n" "${JDBC_PASSWORD:-}"
              printf "JWT_SECRET=%s\n" "${JWT_SECRET:-}"
              printf "JWT_ACCESS_TOKEN_VALIDITY=%s\n" "${JWT_ACCESS_TOKEN_VALIDITY:-}"
              printf "JWT_REFRESH_TOKEN_VALIDITY=%s\n" "${JWT_REFRESH_TOKEN_VALIDITY:-}"
              printf "SEOUL_API_KEY=%s\n" "${SEOUL_API_KEY:-}"
              printf "NATIONAL_API_KEY=%s\n" "${NATIONAL_API_KEY:-}"
              printf "AWS_REGION=%s\n" "${AWS_REGION:-}"
              printf "S3_BUCKET_NAME=%s\n" "${S3_BUCKET_NAME:-}"
              printf "AWS_ACCESS_KEY_ID=%s\n" "${AWS_ACCESS_KEY_ID:-}"
              printf "AWS_SECRET_ACCESS_KEY=%s\n" "${AWS_SECRET_ACCESS_KEY:-}"
              printf "SLACK_WEBHOOK_URL=%s\n" "${SLACK_WEBHOOK_URL:-}"
              printf "GEOCODING_CONTACT_EMAIL=%s\n" "${GEOCODING_CONTACT_EMAIL:-}"
            } > .env
            
            if [ -f .env ]; then
              chmod 600 .env
              echo "‚úÖ .env file created successfully"
              echo "File size: $(wc -c < .env) bytes"
            else
              echo "‚ùå Failed to create .env file"
              exit 1
            fi
            
            # Docker Ïù¥ÎØ∏ÏßÄ pull
            echo ""
            echo "‚¨áÔ∏è Pulling image from Docker Hub..."
            echo "Executing: docker pull $APP_IMAGE"
            if ! docker pull "$APP_IMAGE"; then
              echo "‚ùå Failed to pull Docker image: $APP_IMAGE"
              echo "Please check:"
              echo "1. Image name is correct"
              echo "2. Image exists in Docker Hub"
              echo "3. Docker Hub credentials are valid"
              exit 1
            fi
            echo "‚úÖ Image pulled successfully"
            echo ""
            
            # Docker Compose Î≤ÑÏ†Ñ ÌôïÏù∏
            if docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE="docker compose"
              echo "‚úÖ Using Docker Compose V2"
            elif command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE="docker-compose"
              echo "‚úÖ Using Docker Compose V1"
            else
              echo "‚ùå Docker Compose not found"
              exit 1
            fi
            
            # Í∏∞Ï°¥ Ïª®ÌÖåÏù¥ÎÑà Ï§ëÏßÄ
            echo "üîÑ Stopping existing containers..."
            $DOCKER_COMPOSE down 2>/dev/null || true
            
            # ÏÉà Î≤ÑÏ†Ñ Î∞∞Ìè¨
            export APP_IMAGE
            echo "üîÑ Deploying new version..."
            echo "Executing: $DOCKER_COMPOSE up -d --force-recreate"
            
            if ! $DOCKER_COMPOSE up -d --force-recreate; then
              echo "‚ùå Failed to start container"
              echo "Docker Compose logs:"
              $DOCKER_COMPOSE logs --tail=50
              exit 1
            fi
            
            # Ïª®ÌÖåÏù¥ÎÑà ÏãúÏûë ÎåÄÍ∏∞
            echo ""
            echo "‚è≥ Waiting for container to start..."
            sleep 5
            
            # Ìó¨Ïä§ Ï≤¥ÌÅ¨
            echo "‚è≥ Performing health check..."
            HEALTH_CHECK_PASSED=false
            MAX_ATTEMPTS=40
            SLEEP_BETWEEN=3
            
            for i in $(seq 1 $MAX_ATTEMPTS); do
              sleep "$SLEEP_BETWEEN"
              
              # Ïª®ÌÖåÏù¥ÎÑà ÏÉÅÌÉú ÌôïÏù∏
              if ! docker ps --filter "name=eventitta-app" --filter "status=running" -q | grep -q .; then
                echo "‚ùå Container not running (attempt $i/$MAX_ATTEMPTS)"
                docker logs eventitta-app --tail 50 2>&1 || true
                continue
              fi
              
              # Spring Boot ÏãúÏûë ÌôïÏù∏
              if docker logs eventitta-app 2>&1 | grep -qi "Started.*Application"; then
                echo "‚úÖ Spring Boot application started! (attempt $i/$MAX_ATTEMPTS)"
                
                # HTTP ÏóîÎìúÌè¨Ïù∏Ìä∏ ÌôïÏù∏
                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:${SERVER_PORT}/" 2>/dev/null || echo "000")
                if [ "$HTTP_CODE" != "000" ]; then
                  echo "‚úÖ HTTP endpoint responding with code: $HTTP_CODE"
                  HEALTH_CHECK_PASSED=true
                  break
                fi
              fi
              
              echo "‚è≥ Waiting for application... (attempt $i/$MAX_ATTEMPTS)"
            done
            
            echo ""
            if [ "$HEALTH_CHECK_PASSED" = true ]; then
              echo "$APP_IMAGE" > .current_image
              echo "========================================="
              echo "‚úÖ Deployment Successful!"
              echo "========================================="
              docker ps --filter "name=eventitta-app" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
            else
              echo "========================================="
              echo "‚ùå Deployment Failed!"
              echo "========================================="
              echo "Container logs:"
              docker logs eventitta-app --tail 200 2>&1 || true
              echo ""
              echo "Container status:"
              docker ps -a --filter "name=eventitta-app"
              
              # Î°§Î∞± ÏãúÎèÑ
              if [ -f .current_image ]; then
                PREVIOUS_IMAGE=$(cat .current_image || true)
                if [ -n "$PREVIOUS_IMAGE" ]; then
                  echo ""
                  echo "üîÑ Attempting rollback to: $PREVIOUS_IMAGE"
                  export APP_IMAGE="$PREVIOUS_IMAGE"
                  docker pull "$PREVIOUS_IMAGE" 2>/dev/null || true
                  $DOCKER_COMPOSE up -d --force-recreate
                  echo "‚ö†Ô∏è Rollback completed. Please check the service."
                fi
              fi
              exit 1
            fi
